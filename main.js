/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/embla-carousel/embla-carousel.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/embla-carousel/embla-carousel.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EmblaCarousel)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction isNumber(subject) {\n  return typeof subject === 'number';\n}\nfunction isString(subject) {\n  return typeof subject === 'string';\n}\nfunction isBoolean(subject) {\n  return typeof subject === 'boolean';\n}\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === '[object Object]';\n}\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\nfunction mathSign(n) {\n  return Math.sign(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n  var diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce(function (mergedObjects, currentObject) {\n    objectKeys(currentObject).forEach(function (key) {\n      var valueA = mergedObjects[key];\n      var valueB = currentObject[key];\n      var areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\nfunction isMouseEvent(evt, ownerWindow) {\n  return typeof ownerWindow.MouseEvent !== 'undefined' && evt instanceof ownerWindow.MouseEvent;\n}\nfunction Alignment(align, viewSize) {\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function percent() {\n    return viewSize * Number(align);\n  }\n  function measure(n) {\n    if (isNumber(align)) return percent();\n    return predefined[align](n);\n  }\n  var self = {\n    measure: measure\n  };\n  return self;\n}\nfunction Axis(axis, direction) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n  var startEdge = getStartEdge();\n  var endEdge = getEndEdge();\n  function measureSize(rect) {\n    var width = rect.width,\n      height = rect.height;\n    return scroll === 'x' ? width : height;\n  }\n  function getStartEdge() {\n    if (scroll === 'y') return 'top';\n    return direction === 'rtl' ? 'right' : 'left';\n  }\n  function getEndEdge() {\n    if (scroll === 'y') return 'bottom';\n    return direction === 'rtl' ? 'left' : 'right';\n  }\n  var self = {\n    scroll: scroll,\n    cross: cross,\n    startEdge: startEdge,\n    endEdge: endEdge,\n    measureSize: measureSize\n  };\n  return self;\n}\nfunction Limit(min, max) {\n  var length = mathAbs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  var self = {\n    length: length,\n    max: max,\n    min: min,\n    constrain: constrain,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\nfunction Counter(max, start, loop) {\n  var _Limit = Limit(0, max),\n    constrain = _Limit.constrain;\n  var loopEnd = max + 1;\n  var counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return clone().set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  var self = {\n    get: get,\n    set: set,\n    add: add,\n    clone: clone\n  };\n  return self;\n}\nfunction Direction(direction) {\n  var sign = direction === 'rtl' ? -1 : 1;\n  function apply(n) {\n    return n * sign;\n  }\n  var self = {\n    apply: apply\n  };\n  return self;\n}\nfunction EventStore() {\n  var listeners = [];\n  function add(node, type, handler) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      passive: true\n    };\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n  function clear() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n  }\n  var self = {\n    add: add,\n    clear: clear\n  };\n  return self;\n}\nfunction DragHandler(axis, direction, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction) {\n  var crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var nonPassiveEvent = {\n    passive: false\n  };\n  var initEvents = EventStore();\n  var dragEvents = EventStore();\n  var goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));\n  var snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  var freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  var baseSpeed = dragFree ? 43 : 25;\n  var isMoving = false;\n  var startScroll = 0;\n  var startCross = 0;\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n  function init(emblaApi, watchDrag) {\n    if (!watchDrag) return;\n    function downIfAllowed(evt) {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);\n    }\n    var node = rootNode;\n    initEvents.add(node, 'dragstart', function (evt) {\n      return evt.preventDefault();\n    }, nonPassiveEvent).add(node, 'touchmove', function () {\n      return undefined;\n    }, nonPassiveEvent).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', downIfAllowed).add(node, 'mousedown', downIfAllowed).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click, true);\n  }\n  function destroy() {\n    initEvents.clear();\n    dragEvents.clear();\n  }\n  function addDragEvents() {\n    var node = isMouse ? ownerDocument : rootNode;\n    dragEvents.add(node, 'touchmove', move, nonPassiveEvent).add(node, 'touchend', up).add(node, 'mousemove', move, nonPassiveEvent).add(node, 'mouseup', up);\n  }\n  function isFocusNode(node) {\n    var nodeName = node.nodeName || '';\n    return focusNodes.includes(nodeName);\n  }\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    var next = index.add(mathSign(force) * -1);\n    var baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    var isMouseEvt = isMouseEvent(evt, ownerWindow);\n    isMouse = isMouseEvt;\n    if (isMouseEvt && evt.button !== 0) return;\n    if (isFocusNode(evt.target)) return;\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;\n    isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    scrollBody.useFriction(0).useDuration(0);\n    target.set(location);\n    addDragEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit('pointerDown');\n  }\n  function move(evt) {\n    var lastScroll = dragTracker.readPoint(evt);\n    var lastCross = dragTracker.readPoint(evt, crossAxis);\n    var diffScroll = deltaAbs(lastScroll, startScroll);\n    var diffCross = deltaAbs(lastCross, startCross);\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll) return up(evt);\n    }\n    var diff = dragTracker.pointerMove(evt);\n    if (diffScroll > dragThreshold) preventClick = true;\n    scrollBody.useFriction(0.3).useDuration(1);\n    animation.start();\n    target.add(direction.apply(diff));\n    evt.preventDefault();\n  }\n  function up(evt) {\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    var force = allowedForce(direction.apply(rawForce), targetChanged);\n    var forceFactor = factorAbs(rawForce, force);\n    var speed = baseSpeed - 10 * forceFactor;\n    var friction = baseFriction + forceFactor / 50;\n    preventScroll = false;\n    pointerIsDown = false;\n    dragEvents.clear();\n    scrollBody.useDuration(speed).useFriction(friction);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit('pointerUp');\n  }\n  function click(evt) {\n    if (preventClick) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    }\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  var self = {\n    init: init,\n    pointerDown: pointerDown,\n    destroy: destroy\n  };\n  return self;\n}\nfunction DragTracker(axis, ownerWindow) {\n  var logInterval = 170;\n  var startEvent;\n  var lastEvent;\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n  function readPoint(evt, evtAxis) {\n    var property = evtAxis || axis.scroll;\n    var coord = \"client\".concat(property === 'x' ? 'X' : 'Y');\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];\n  }\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n  function pointerMove(evt) {\n    var diff = readPoint(evt) - readPoint(lastEvent);\n    var expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired) startEvent = evt;\n    return diff;\n  }\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent) return 0;\n    var diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    var diffTime = readTime(evt) - readTime(startEvent);\n    var expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    var force = diffDrag / diffTime;\n    var isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n  var self = {\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n  var self = {\n    measure: measure\n  };\n  return self;\n}\nfunction ResizeHandler(container, eventHandler, ownerWindow, slides, axis) {\n  var resizeObserver;\n  var containerSize;\n  var slideSizes = [];\n  var destroyed = false;\n  function readSize(node) {\n    return axis.measureSize(node.getBoundingClientRect());\n  }\n  function init(emblaApi, watchResize) {\n    if (!watchResize) return;\n    containerSize = readSize(container);\n    slideSizes = slides.map(readSize);\n    function defaultCallback(entries) {\n      var _iterator = _createForOfIteratorHelper(entries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          var isContainer = entry.target === container;\n          var slideIndex = slides.indexOf(entry.target);\n          var lastSize = isContainer ? containerSize : slideSizes[slideIndex];\n          var newSize = readSize(isContainer ? container : slides[slideIndex]);\n          if (lastSize !== newSize) {\n            ownerWindow.requestAnimationFrame(function () {\n              emblaApi.reInit();\n              eventHandler.emit('resize');\n            });\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    resizeObserver = new ResizeObserver(function (entries) {\n      if (destroyed) return;\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries);\n      }\n    });\n    var observeNodes = [container].concat(slides);\n    observeNodes.forEach(function (node) {\n      return resizeObserver.observe(node);\n    });\n  }\n  function destroy() {\n    if (resizeObserver) resizeObserver.disconnect();\n    destroyed = true;\n  }\n  var self = {\n    init: init,\n    destroy: destroy\n  };\n  return self;\n}\nfunction ScrollBody(location, target, baseDuration, baseFriction) {\n  var hasSettled = true;\n  var bodyVelocity = 0;\n  var scrollDirection = 0;\n  var duration = baseDuration;\n  var friction = baseFriction;\n  function seek() {\n    var diff = target.get() - location.get();\n    var isInstant = !friction || !duration;\n    if (isInstant) {\n      bodyVelocity = 0;\n      location.set(target);\n    } else {\n      bodyVelocity += diff / duration;\n      bodyVelocity *= friction;\n      location.add(bodyVelocity);\n    }\n    scrollDirection = mathSign(bodyVelocity || diff);\n    hasSettled = mathAbs(diff) < 0.001;\n    return self;\n  }\n  function settled() {\n    if (hasSettled) location.set(target);\n    return hasSettled;\n  }\n  function velocity() {\n    return bodyVelocity;\n  }\n  function direction() {\n    return scrollDirection;\n  }\n  function useBaseDuration() {\n    return useDuration(baseDuration);\n  }\n  function useBaseFriction() {\n    return useFriction(baseFriction);\n  }\n  function useDuration(n) {\n    duration = n;\n    return self;\n  }\n  function useFriction(n) {\n    friction = n;\n    return self;\n  }\n  var self = {\n    direction: direction,\n    seek: seek,\n    settled: settled,\n    useBaseFriction: useBaseFriction,\n    useBaseDuration: useBaseDuration,\n    useFriction: useFriction,\n    useDuration: useDuration,\n    velocity: velocity\n  };\n  return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  var pullBackThreshold = percentOfView.measure(10);\n  var edgeOffsetTolerance = percentOfView.measure(50);\n  var frictionLimit = Limit(0.1, 0.99);\n  var disabled = false;\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    var edge = limit.reachedMin(location.get()) ? 'min' : 'max';\n    var diffToEdge = mathAbs(limit[edge] - location.get());\n    var diffToTarget = target.get() - location.get();\n    var friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useDuration(25).useBaseFriction();\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll) {\n  var scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0]);\n  var snapsBounded = measureBounded();\n  var snapsContained = measureContained();\n  function findDuplicates() {\n    var startSnap = snapsBounded[0];\n    var endSnap = arrayLast(snapsBounded);\n    var min = snapsBounded.lastIndexOf(startSnap);\n    var max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureBounded() {\n    return snapsAligned.map(scrollBounds.constrain).map(function (scrollBound) {\n      return parseFloat(scrollBound.toFixed(3));\n    });\n  }\n  function measureContained() {\n    if (contentSize <= viewSize) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n    var _findDuplicates = findDuplicates(),\n      min = _findDuplicates.min,\n      max = _findDuplicates.max;\n    return snapsBounded.slice(min, max);\n  }\n  var self = {\n    snapsContained: snapsContained\n  };\n  return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  var max = scrollSnaps[0];\n  var min = loop ? max - contentSize : arrayLast(scrollSnaps);\n  var limit = Limit(min, max);\n  var self = {\n    limit: limit\n  };\n  return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  var jointSafety = 0.1;\n  var min = limit.min + jointSafety;\n  var max = limit.max + jointSafety;\n  var _Limit2 = Limit(min, max),\n    reachedMin = _Limit2.reachedMin,\n    reachedMax = _Limit2.reachedMax;\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n  var self = {\n    loop: loop\n  };\n  return self;\n}\nfunction ScrollProgress(limit) {\n  var max = limit.max,\n    scrollLength = limit.length;\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n  var self = {\n    get: get\n  };\n  return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containScroll) {\n  var startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var groupSlides = slidesToScroll.groupSlides;\n  var alignments = measureSizes().map(alignment.measure);\n  var snaps = measureUnaligned();\n  var snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupSlides(slideRects).map(function (rects) {\n      return arrayLast(rects)[endEdge] - rects[0][startEdge];\n    }).map(mathAbs);\n  }\n  function measureUnaligned() {\n    return slideRects.map(function (rect) {\n      return containerRect[startEdge] - rect[startEdge];\n    }).map(function (snap) {\n      return -mathAbs(snap);\n    });\n  }\n  function measureAligned() {\n    var containedStartSnap = 0;\n    var containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps);\n    return groupSlides(snaps).map(function (g) {\n      return g[0];\n    }).map(function (snap, index, groupedSnaps) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(groupedSnaps);\n      if (containScroll && isFirst) return containedStartSnap;\n      if (containScroll && isLast) return containedEndSnap;\n      return snap + alignments[index];\n    });\n  }\n  var self = {\n    snaps: snaps,\n    snapsAligned: snapsAligned\n  };\n  return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  var reachedAny = limit.reachedAny,\n    removeOffset = limit.removeOffset,\n    constrain = limit.constrain;\n  function minDistance(distances) {\n    return distances.concat().sort(function (a, b) {\n      return mathAbs(a) - mathAbs(b);\n    })[0];\n  }\n  function findTargetSnap(target) {\n    var distance = loop ? removeOffset(target) : constrain(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return mathAbs(d1.diff) - mathAbs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function shortcut(target, direction) {\n    var targets = [target, target + contentSize, target - contentSize];\n    if (!loop) return targets[0];\n    if (!direction) return minDistance(targets);\n    var matchingTargets = targets.filter(function (t) {\n      return mathSign(t) === direction;\n    });\n    return minDistance(matchingTargets);\n  }\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - targetVector.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function byDistance(distance, snap) {\n    var target = targetVector.get() + distance;\n    var _findTargetSnap = findTargetSnap(target),\n      index = _findTargetSnap.index,\n      targetSnapDistance = _findTargetSnap.distance;\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n    if (distanceDiff) {\n      animation.start();\n      targetVector.add(distanceDiff);\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit('select');\n    }\n  }\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\nfunction Vector1D(initialValue) {\n  var value = initialValue;\n  function get() {\n    return value;\n  }\n  function set(n) {\n    value = normalizeInput(n);\n  }\n  function add(n) {\n    value += normalizeInput(n);\n  }\n  function subtract(n) {\n    value -= normalizeInput(n);\n  }\n  function normalizeInput(n) {\n    return isNumber(n) ? n : n.get();\n  }\n  var self = {\n    get: get,\n    set: set,\n    add: add,\n    subtract: subtract\n  };\n  return self;\n}\nfunction Translate(axis, direction, container) {\n  var translate = axis.scroll === 'x' ? x : y;\n  var containerStyle = container.style;\n  var disabled = false;\n  function x(n) {\n    return \"translate3d(\".concat(n, \"px,0px,0px)\");\n  }\n  function y(n) {\n    return \"translate3d(0px,\".concat(n, \"px,0px)\");\n  }\n  function to(target) {\n    if (disabled) return;\n    containerStyle.transform = translate(direction.apply(target));\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    if (disabled) return;\n    containerStyle.transform = '';\n    if (!container.getAttribute('style')) container.removeAttribute('style');\n  }\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, scroll, slides) {\n  var ascItems = arrayKeys(slideSizesWithGaps);\n  var descItems = arrayKeys(slideSizesWithGaps).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce(function (a, i) {\n      var remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findLoopPoints(indexes, edge) {\n    var isStartEdge = edge === 'start';\n    var offset = isStartEdge ? -contentSize : contentSize;\n    var slideBounds = slidesInView.findSlideBounds([offset]);\n    return indexes.map(function (index) {\n      var initial = isStartEdge ? 0 : -contentSize;\n      var altered = isStartEdge ? contentSize : 0;\n      var bounds = slideBounds.filter(function (b) {\n        return b.index === index;\n      })[0];\n      var point = bounds[isStartEdge ? 'end' : 'start'];\n      var location = Vector1D(-1);\n      var translate = Translate(axis, direction, slides[index]);\n      var target = function target() {\n        return scroll.get() > point ? initial : altered;\n      };\n      return {\n        index: index,\n        location: location,\n        translate: translate,\n        target: target\n      };\n    });\n  }\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, 'end');\n  }\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, 'start');\n  }\n  function canLoop() {\n    return loopPoints.every(function (_ref) {\n      var index = _ref.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n  function loop() {\n    loopPoints.forEach(function (loopPoint) {\n      var target = loopPoint.target,\n        translate = loopPoint.translate,\n        location = loopPoint.location;\n      var shift = target();\n      if (shift === location.get()) return;\n      translate.to(shift);\n      location.set(shift);\n    });\n  }\n  function clear() {\n    loopPoints.forEach(function (loopPoint) {\n      return loopPoint.translate.clear();\n    });\n  }\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\nfunction SlidesHandler(container, eventHandler) {\n  var mutationObserver;\n  var destroyed = false;\n  function init(emblaApi, watchSlides) {\n    if (!watchSlides) return;\n    function defaultCallback(mutations) {\n      var _iterator2 = _createForOfIteratorHelper(mutations),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mutation = _step2.value;\n          if (mutation.type === 'childList') {\n            emblaApi.reInit();\n            eventHandler.emit('slidesChanged');\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    mutationObserver = new MutationObserver(function (mutations) {\n      if (destroyed) return;\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations);\n      }\n    });\n    mutationObserver.observe(container, {\n      childList: true\n    });\n  }\n  function destroy() {\n    if (mutationObserver) mutationObserver.disconnect();\n    destroyed = true;\n  }\n  var self = {\n    init: init,\n    destroy: destroy\n  };\n  return self;\n}\nfunction SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold) {\n  var removeOffset = limit.removeOffset,\n    constrain = limit.constrain;\n  var roundingSafety = 0.5;\n  var cachedOffsets = loop ? [0, contentSize, -contentSize] : [0];\n  var cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold);\n  function findSlideThresholds(threshold) {\n    var slideThreshold = threshold || 0;\n    return slideSizes.map(function (slideSize) {\n      var thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety);\n      return thresholdLimit.constrain(slideSize * slideThreshold);\n    });\n  }\n  function findSlideBounds(offsets, threshold) {\n    var slideOffsets = offsets || cachedOffsets;\n    var slideThresholds = findSlideThresholds(threshold);\n    return slideOffsets.reduce(function (list, offset) {\n      var bounds = snaps.map(function (snap, index) {\n        return {\n          start: snap - slideSizes[index] + slideThresholds[index] + offset,\n          end: snap + viewSize - slideThresholds[index] + offset,\n          index: index\n        };\n      });\n      return list.concat(bounds);\n    }, []);\n  }\n  function check(location, bounds) {\n    var limitedLocation = loop ? removeOffset(location) : constrain(location);\n    var slideBounds = bounds || cachedBounds;\n    return slideBounds.reduce(function (list, slideBound) {\n      var index = slideBound.index,\n        start = slideBound.start,\n        end = slideBound.end;\n      var inList = list.includes(index);\n      var inView = start < limitedLocation && end > limitedLocation;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n  var self = {\n    check: check,\n    findSlideBounds: findSlideBounds\n  };\n  return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {\n  var measureSize = axis.measureSize,\n    startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var withEdgeGap = slideRects[0] && readEdgeGap;\n  var startGap = measureStartGap();\n  var endGap = measureEndGap();\n  var slideSizes = slideRects.map(measureSize);\n  var slideSizesWithGaps = measureWithGaps();\n  function measureStartGap() {\n    if (!withEdgeGap) return 0;\n    var slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n  function measureEndGap() {\n    if (!withEdgeGap) return 0;\n    var style = ownerWindow.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(\"margin-\".concat(endEdge)));\n  }\n  function measureWithGaps() {\n    return slideRects.map(function (rect, index, rects) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(rects);\n      if (isFirst) return slideSizes[index] + startGap;\n      if (isLast) return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n  var self = {\n    slideSizes: slideSizes,\n    slideSizesWithGaps: slideSizesWithGaps\n  };\n  return self;\n}\nfunction SlidesToScroll(viewSize, slideSizesWithGaps, slidesToScroll) {\n  var groupByNumber = isNumber(slidesToScroll);\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter(function (i) {\n      return i % groupSize === 0;\n    }).map(function (i) {\n      return array.slice(i, i + groupSize);\n    });\n  }\n  function bySize(array) {\n    return arrayKeys(array).reduce(function (groupSizes, i) {\n      var chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1);\n      var chunkSize = chunk.reduce(function (a, s) {\n        return a + s;\n      }, 0);\n      return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes;\n    }, []).map(function (start, i, groupSizes) {\n      return array.slice(start, groupSizes[i + 1]);\n    });\n  }\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n  var self = {\n    groupSlides: groupSlides\n  };\n  return self;\n}\nfunction Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations) {\n  // Options\n  var align = options.align,\n    scrollAxis = options.axis,\n    contentDirection = options.direction,\n    startIndex = options.startIndex,\n    inViewThreshold = options.inViewThreshold,\n    loop = options.loop,\n    duration = options.duration,\n    dragFree = options.dragFree,\n    dragThreshold = options.dragThreshold,\n    groupSlides = options.slidesToScroll,\n    skipSnaps = options.skipSnaps,\n    containScroll = options.containScroll;\n  // Measurements\n  var containerRect = container.getBoundingClientRect();\n  var slideRects = slides.map(function (slide) {\n    return slide.getBoundingClientRect();\n  });\n  var direction = Direction(contentDirection);\n  var axis = Axis(scrollAxis, contentDirection);\n  var viewSize = axis.measureSize(containerRect);\n  var percentOfView = PercentOfView(viewSize);\n  var alignment = Alignment(align, viewSize);\n  var containSnaps = !loop && !!containScroll;\n  var readEdgeGap = loop || !!containScroll;\n  var _SlideSizes = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow),\n    slideSizes = _SlideSizes.slideSizes,\n    slideSizesWithGaps = _SlideSizes.slideSizesWithGaps;\n  var slidesToScroll = SlidesToScroll(viewSize, slideSizesWithGaps, groupSlides);\n  var _ScrollSnaps = ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containSnaps),\n    snaps = _ScrollSnaps.snaps,\n    snapsAligned = _ScrollSnaps.snapsAligned;\n  var contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  var _ScrollContain = ScrollContain(viewSize, contentSize, snapsAligned, containScroll),\n    snapsContained = _ScrollContain.snapsContained;\n  var scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  var _ScrollLimit = ScrollLimit(contentSize, scrollSnaps, loop),\n    limit = _ScrollLimit.limit;\n  // Indexes\n  var index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  var indexPrevious = index.clone();\n  var slideIndexes = arrayKeys(slides);\n  // Animation\n  var _update = function update(_ref2) {\n    var dragHandler = _ref2.dragHandler,\n      scrollBody = _ref2.scrollBody,\n      scrollBounds = _ref2.scrollBounds,\n      scrollLooper = _ref2.scrollLooper,\n      slideLooper = _ref2.slideLooper,\n      eventHandler = _ref2.eventHandler,\n      animation = _ref2.animation,\n      loop = _ref2.options.loop;\n    var pointerDown = dragHandler.pointerDown();\n    if (!loop) scrollBounds.constrain(pointerDown);\n    var hasSettled = scrollBody.seek().settled();\n    if (hasSettled && !pointerDown) {\n      animation.stop();\n      eventHandler.emit('settle');\n    }\n    if (!hasSettled) {\n      eventHandler.emit('scroll');\n    }\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction());\n      slideLooper.loop();\n    }\n  };\n  var _render = function render(_ref3, lagOffset) {\n    var scrollBody = _ref3.scrollBody,\n      translate = _ref3.translate,\n      location = _ref3.location;\n    var velocity = scrollBody.velocity();\n    var offsetLocation = location.get() - velocity + velocity * lagOffset;\n    translate.to(offsetLocation);\n  };\n  var animation = {\n    update: function update() {\n      return _update(engine);\n    },\n    render: function render(lagOffset) {\n      return _render(engine, lagOffset);\n    },\n    start: function start() {\n      return animations.start(engine);\n    },\n    stop: function stop() {\n      return animations.stop(engine);\n    }\n  };\n  // Shared\n  var friction = 0.68;\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var scrollBody = ScrollBody(location, target, duration, friction);\n  var scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  var scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, eventHandler);\n  var slidesInView = SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold);\n  // Engine\n  var engine = {\n    ownerDocument: ownerDocument,\n    ownerWindow: ownerWindow,\n    eventHandler: eventHandler,\n    containerRect: containerRect,\n    slideRects: slideRects,\n    animation: animation,\n    axis: axis,\n    direction: direction,\n    dragHandler: DragHandler(axis, direction, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction),\n    eventStore: EventStore(),\n    percentOfView: percentOfView,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis),\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [location, target]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, location, slides),\n    slidesHandler: SlidesHandler(container, eventHandler),\n    slidesInView: slidesInView,\n    slideIndexes: slideIndexes,\n    slidesToScroll: slidesToScroll,\n    target: target,\n    translate: Translate(axis, direction, container)\n  };\n  return engine;\n}\nfunction Animations(ownerWindow) {\n  var timeStep = 1000 / 60;\n  var engines = [];\n  var lastTimeStamp = null;\n  var lag = 0;\n  var animationFrame = 0;\n  function animate(timeStamp) {\n    if (!lastTimeStamp) lastTimeStamp = timeStamp;\n    var elapsed = timeStamp - lastTimeStamp;\n    lastTimeStamp = timeStamp;\n    lag += elapsed;\n    while (lag >= timeStep) {\n      engines.forEach(function (_ref4) {\n        var animation = _ref4.animation;\n        return animation.update();\n      });\n      lag -= timeStep;\n    }\n    var lagOffset = mathAbs(lag / timeStep);\n    engines.forEach(function (_ref5) {\n      var animation = _ref5.animation;\n      return animation.render(lagOffset);\n    });\n    if (animationFrame) ownerWindow.requestAnimationFrame(animate);\n  }\n  function start(engine) {\n    if (!engines.includes(engine)) engines.push(engine);\n    if (animationFrame) return;\n    animationFrame = ownerWindow.requestAnimationFrame(animate);\n  }\n  function stop(engine) {\n    engines = engines.filter(function (e) {\n      return e !== engine;\n    });\n    if (engines.length) return;\n    ownerWindow.cancelAnimationFrame(animationFrame);\n    lastTimeStamp = null;\n    lag = 0;\n    animationFrame = 0;\n  }\n  function reset() {\n    lastTimeStamp = null;\n    lag = 0;\n  }\n  var self = {\n    start: start,\n    stop: stop,\n    reset: reset,\n    window: ownerWindow\n  };\n  return self;\n}\nfunction EventHandler() {\n  var listeners = {};\n  var api;\n  function init(emblaApi) {\n    api = emblaApi;\n  }\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach(function (e) {\n      return e(api, evt);\n    });\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n  var self = {\n    init: init,\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: null,\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true\n};\nfunction OptionsHandler(ownerWindow) {\n  function mergeOptions(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n  function optionsAtMedia(options) {\n    var optionsAtMedia = options.breakpoints || {};\n    var matchedMediaOptions = objectKeys(optionsAtMedia).filter(function (media) {\n      return ownerWindow.matchMedia(media).matches;\n    }).map(function (media) {\n      return optionsAtMedia[media];\n    }).reduce(function (a, mediaOption) {\n      return mergeOptions(a, mediaOption);\n    }, {});\n    return mergeOptions(options, matchedMediaOptions);\n  }\n  function optionsMediaQueries(optionsList) {\n    return optionsList.map(function (options) {\n      return objectKeys(options.breakpoints || {});\n    }).reduce(function (acc, mediaQueries) {\n      return acc.concat(mediaQueries);\n    }, []).map(ownerWindow.matchMedia);\n  }\n  var self = {\n    mergeOptions: mergeOptions,\n    optionsAtMedia: optionsAtMedia,\n    optionsMediaQueries: optionsMediaQueries\n  };\n  return self;\n}\nfunction PluginsHandler(optionsHandler) {\n  var activePlugins = [];\n  function init(plugins, emblaApi) {\n    activePlugins = plugins.filter(function (_ref6) {\n      var options = _ref6.options;\n      return optionsHandler.optionsAtMedia(options).active !== false;\n    });\n    activePlugins.forEach(function (plugin) {\n      return plugin.init(emblaApi, optionsHandler);\n    });\n    return plugins.reduce(function (map, plugin) {\n      return Object.assign(map, _defineProperty({}, plugin.name, plugin));\n    }, {});\n  }\n  function destroy() {\n    activePlugins = activePlugins.filter(function (plugin) {\n      return plugin.destroy();\n    });\n  }\n  var self = {\n    init: init,\n    destroy: destroy\n  };\n  return self;\n}\nfunction EmblaCarousel(root, userOptions, userPlugins) {\n  var ownerDocument = root.ownerDocument;\n  var ownerWindow = ownerDocument.defaultView;\n  var optionsHandler = OptionsHandler(ownerWindow);\n  var pluginsHandler = PluginsHandler(optionsHandler);\n  var mediaHandlers = EventStore();\n  var documentVisibleHandler = EventStore();\n  var eventHandler = EventHandler();\n  var animationRealms = EmblaCarousel.animationRealms;\n  var mergeOptions = optionsHandler.mergeOptions,\n    optionsAtMedia = optionsHandler.optionsAtMedia,\n    optionsMediaQueries = optionsHandler.optionsMediaQueries;\n  var on = eventHandler.on,\n    off = eventHandler.off,\n    emit = eventHandler.emit;\n  var reInit = reActivate;\n  var destroyed = false;\n  var engine;\n  var optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);\n  var options = mergeOptions(optionsBase);\n  var pluginList = [];\n  var pluginApis;\n  var container;\n  var slides;\n  function storeElements() {\n    var _options = options,\n      userContainer = _options.container,\n      userSlides = _options.slides;\n    var customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;\n    container = customContainer || root.children[0];\n    var customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;\n    slides = [].slice.call(customSlides || container.children);\n  }\n  function activate(withOptions, withPlugins) {\n    if (destroyed) return;\n    var animationRealm = animationRealms.find(function (a) {\n      return a.window === ownerWindow;\n    });\n    var animations = animationRealm || Animations(ownerWindow);\n    if (!animationRealm) animationRealms.push(animations);\n    optionsBase = mergeOptions(optionsBase, withOptions);\n    options = optionsAtMedia(optionsBase);\n    pluginList = withPlugins || pluginList;\n    storeElements();\n    engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler, animations);\n    optionsMediaQueries([optionsBase].concat(_toConsumableArray(pluginList.map(function (_ref7) {\n      var options = _ref7.options;\n      return options;\n    })))).forEach(function (query) {\n      return mediaHandlers.add(query, 'change', reActivate);\n    });\n    if (!options.active) return;\n    engine.translate.to(engine.location.get());\n    engine.eventHandler.init(self);\n    engine.resizeHandler.init(self, options.watchResize);\n    engine.slidesHandler.init(self, options.watchSlides);\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', function () {\n      if (ownerDocument.hidden) animations.reset();\n    });\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate();\n        activate({\n          loop: false\n        }, withPlugins);\n        optionsBase = mergeOptions(optionsBase, {\n          loop: true\n        });\n        return;\n      }\n      engine.slideLooper.loop();\n    }\n    if (container.offsetParent && slides.length) {\n      engine.dragHandler.init(self, options.watchDrag);\n    }\n    pluginApis = pluginsHandler.init(pluginList, self);\n  }\n  function reActivate(withOptions, withPlugins) {\n    var startIndex = selectedScrollSnap();\n    deActivate();\n    activate(mergeOptions({\n      startIndex: startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit('reInit');\n  }\n  function deActivate() {\n    engine.dragHandler.destroy();\n    engine.animation.stop();\n    engine.eventStore.clear();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    engine.resizeHandler.destroy();\n    engine.slidesHandler.destroy();\n    pluginsHandler.destroy();\n    mediaHandlers.clear();\n    documentVisibleHandler.clear();\n  }\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n    mediaHandlers.clear();\n    deActivate();\n    eventHandler.emit('destroy');\n  }\n  function slidesInView(target) {\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n  function slidesNotInView(target) {\n    var inView = slidesInView(target);\n    return engine.slideIndexes.filter(function (index) {\n      return !inView.includes(index);\n    });\n  }\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed) return;\n    engine.scrollBody.useBaseFriction().useDuration(jump ? 0 : options.duration);\n    engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    var next = engine.index.add(1).get();\n    scrollTo(next, jump === true, -1);\n  }\n  function scrollPrev(jump) {\n    var prev = engine.index.add(-1).get();\n    scrollTo(prev, jump === true, 1);\n  }\n  function canScrollNext() {\n    var next = engine.index.add(1).get();\n    return next !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    var prev = engine.index.add(-1).get();\n    return prev !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function plugins() {\n    return pluginApis;\n  }\n  function internalEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return root;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    containerNode: containerNode,\n    internalEngine: internalEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    emit: emit,\n    plugins: plugins,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    rootNode: rootNode,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  setTimeout(function () {\n    return eventHandler.emit('init');\n  }, 0);\n  return self;\n}\nEmblaCarousel.animationRealms = [];\nEmblaCarousel.globalOptions = undefined;\n\n\n//# sourceURL=webpack://moto/./node_modules/embla-carousel/embla-carousel.esm.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.css */ \"./src/styles/index.css\");\n/* harmony import */ var embla_carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! embla-carousel */ \"./node_modules/embla-carousel/embla-carousel.esm.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n// Grab wrapper nodes\nvar rootNode = document.querySelector('.embla');\nvar viewportNode = rootNode.querySelector('.embla__viewport');\nvar OPTIONS = {\n  slidesToScroll: 1,\n  loop: true,\n  watchDrag: false,\n  inViewThreshold: 0.1,\n  align: 0,\n  breakpoints: {\n    '(max-width: 599px)': {\n      watchDrag: true\n    }\n  }\n};\nvar emblaApi = (0,embla_carousel__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(viewportNode, OPTIONS);\n\n// Grab button nodes\nvar prevButtonNode = rootNode.querySelector('.embla__prev');\nvar nextButtonNode = rootNode.querySelector('.embla__next');\nvar rootNodeMoto = document.querySelector('.embla_moto');\nvar viewportNodeMoto = rootNodeMoto.querySelector('.embla__viewport_moto');\nvar emblaApiMoto = (0,embla_carousel__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(viewportNodeMoto, OPTIONS);\n\n// Grab button nodes\nvar prevButtonNodeMoto = rootNodeMoto.querySelector('.embla__prev_moto');\nvar nextButtonNodeMoto = rootNodeMoto.querySelector('.embla__next_moto');\nprevButtonNodeMoto.addEventListener('click', emblaApiMoto.scrollPrev, false);\nnextButtonNodeMoto.addEventListener('click', emblaApiMoto.scrollNext, false);\nvar popupAuto = document.querySelector('.popup__auto');\nvar openPopupAutoButton = document.querySelector('.button__popup-auto');\nvar popupMoto = document.querySelector('.popup__moto');\nvar openPopupMotoButton = document.querySelector('.button__popup-moto');\nvar closePopupButtons = document.querySelectorAll('.popup__close');\nvar closePopupsClickShadow = function closePopupsClickShadow(evt) {\n  if (evt.target.classList.contains('popup')) {\n    allPopupsClose();\n  }\n};\nopenPopupAutoButton.addEventListener('click', function () {\n  popupAuto.addEventListener('click', closePopupsClickShadow);\n  popupAuto.classList.add('popup_opened');\n  document.addEventListener('keydown', handleEscClose);\n});\nopenPopupMotoButton.addEventListener('click', function () {\n  popupMoto.addEventListener('click', closePopupsClickShadow);\n  popupMoto.classList.add('popup_opened');\n  document.addEventListener('keydown', handleEscClose);\n});\nclosePopupButtons.forEach(function (button) {\n  button.addEventListener('click', function (e) {\n    e.target.closest('.popup').classList.remove('popup_opened');\n    document.removeEventListener('keydown', handleEscClose);\n  });\n});\n\n// Add click listeners\nprevButtonNode.addEventListener('click', emblaApi.scrollPrev, false);\nnextButtonNode.addEventListener('click', emblaApi.scrollNext, false);\nvar anchors = document.querySelectorAll('a[href*=\"#\"]');\nvar _iterator = _createForOfIteratorHelper(anchors),\n  _step;\ntry {\n  var _loop = function _loop() {\n    var anchor = _step.value;\n    anchor.addEventListener('click', function (e) {\n      e.preventDefault();\n      var blockID = anchor.getAttribute('href');\n      document.querySelector(\"\".concat(blockID)).scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\"\n      });\n    });\n  };\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    _loop();\n  }\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}\nvar buttonOpenBurger = document.querySelector('.burger__button');\nvar buttonCloseBurger = document.querySelector('.burger__button-esc');\nvar burgerMenu = document.querySelector('.burger');\nvar allPopupsClose = function allPopupsClose() {\n  popupAuto.classList.remove('popup_opened');\n  popupMoto.classList.remove('popup_opened');\n  popupBooking.classList.remove('popup_opened');\n};\nvar handleEscClose = function handleEscClose(evt) {\n  if (evt.key === 'Escape') {\n    allPopupsClose();\n    document.removeEventListener('keydown', handleEscClose);\n  }\n};\nbuttonOpenBurger.addEventListener('click', function () {\n  burgerMenu.classList.add('burger_active');\n});\nbuttonCloseBurger.addEventListener('click', function () {\n  burgerMenu.classList.remove('burger_active');\n});\nvar popupBooking = document.querySelector('.popup__booking');\nvar popupBookingOpenButtons = document.querySelectorAll('.booking-open');\npopupBookingOpenButtons.forEach(function (button) {\n  button.addEventListener('click', function (evt) {\n    moto = evt.target.closest('.embla__slide').querySelector('.swiper-slide__title').textContent;\n    popupBooking.classList.add('popup_opened');\n    popupBooking.addEventListener('click', function (evt) {\n      if (evt.target.classList.contains('popup')) {\n        popupBooking.classList.remove('popup_opened');\n      }\n    });\n  });\n});\nvar formBooking = popupBooking.querySelector('.booking__form');\nformBooking.addEventListener('submit', function (evt) {\n  handleFormSubmit(evt);\n});\nvar moto;\nvar handleFormSubmit = function handleFormSubmit(evt) {\n  evt.preventDefault();\n  var response = grecaptcha.getResponse();\n  if (response.length == 0) {\n    document.getElementById('g-recaptcha-error').innerHTML = '<span style=\"color:red;\">This field is required.</span>';\n    return false;\n  } else {\n    var name = popupBooking.querySelector('.input-name').value;\n    var number = popupBooking.querySelector('.input-number').value;\n    var dataStart = popupBooking.querySelector('.input-date-start').value;\n    var msg = \"\\u0411\\u0440\\u043E\\u043D\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \".concat(moto, \"%0A\\u0418\\u043C\\u044F: \").concat(name, \"%0A\\u041D\\u043E\\u043C\\u0435\\u0440 \\u0442\\u0435\\u043B\\u0435\\u0444\\u043E\\u043D\\u0430: \").concat(number, \"%0A\\u0414\\u0430\\u0442\\u0430 \\u0431\\u0440\\u043E\\u043D\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F: \").concat(dataStart);\n    fetch(\"https://api.telegram.org/bot6116212100:AAHrlP2hSxuHfFXcjJ-haZ35CZbbypQcGoE/sendMessage?chat_id=-1001927500705&parse_mode=html&text=\".concat(msg), {\n      method: 'GET'\n    }).then(allPopupsClose()).catch(console.error);\n  }\n};\nfunction verifyCaptcha() {\n  document.getElementById('g-recaptcha-error').innerHTML = '';\n}\n\n//# sourceURL=webpack://moto/./src/index.js?");

/***/ }),

/***/ "./src/styles/index.css":
/*!******************************!*\
  !*** ./src/styles/index.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://moto/./src/styles/index.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;